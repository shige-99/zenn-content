---
title: "Git完全に理解する"
emoji: "🌲"
type: "tech"
topics:
  - "git"
  - "github"
published: true
published_at: "2024-07-17 19:28"
---

## はじめに
本記事は、社内勉強会でGitを学ぶための参考資料として作成しました。Gitの概念から実際の操作までを扱い、本記事を通じてGitの理解を深めることを目的としています。
:::message
Gitは奥深く、簡単ではありません。ここでの「完全に理解する」とは以下の操作をできる状態を指します。

1. **リポジトリの作成とクローン**
2. **コミットの基本操作**
3. **ブランチの管理**
4. **リモートリポジトリの操作**
5. **差分の確認**
6. **コンフリクトの解決**
7. **ログの確認**
8. **リセットやリバート**
:::

## 対象者
・Git聞いたことあるけど、使った事ない人
・Git完全に理解していない人

## Gitとは
Wikiを引用すると、
>Gitは、プログラムのソースコードなどの変更履歴を記録・追跡するための分散型バージョン管理システムである。

通常、ファイルを編集して保存すると古いデータは破棄され、最新のデータで上書きされます。つまり、最新のデータのみ参照できます。しかし、Gitを使うと過去のデータも確認・復元ができます。
:::message
分散型バージョン管理システムについては本記事では解説しませんが、下記サイトで分かりやすく解説されています。
[【初心者】【バージョン管理】中央集中型システムと分散型システムについて](https://qiita.com/y518gaku/items/9a789b4bddfabe687dfa)
:::

### Gitを本で例える
ここでは、Gitの操作や機能に関連する重要な用語を本を例にして解説します。

#### リポジトリ（Repository）
例え: 本棚

リポジトリは、本の「本棚」のようなものです。この本棚には、プロジェクト全体のすべての章（ファイル）やそのバージョン（変更履歴）が保存されています。

#### ステージング（Staging）
例え: 下書きノート

ステージングは、原稿を「下書きノート」にまとめることに似ています。すぐに本にするのではなく、まずノートに一旦書き留めてから、本にする準備を整えます。

#### コミット（Commit）
例え: 正式な章

コミットは、下書きノートに書いた内容を「正式な章」として本に含めることです。ノートに書いた内容が本に追加され、正式な一部となります。

#### ブランチ（Branch）
例え: 別の草稿

ブランチは、本の別の「草稿」を作成することです。主な内容から分岐して、異なるバージョンや試作品を並行して作成できます。最終的に、必要に応じてこれらの草稿を本に統合することができます（マージ）。

#### マージ（Merge）
例え: 草稿の統合

マージは、別々に作成した草稿を「統合」することです。複数のバージョンを一つの本にまとめ、異なるアイデアや修正を組み合わせます。コンフリクトが発生する場合は、手動で調整して一つのまとまった内容にします。

#### プルリクエスト（Pull Request）
例え: 編集者への提案

プルリクエストは、他の編集者に自分の草稿をレビューしてもらい、本に含めるかどうかの判断を仰ぐことです。これにより、他の人の意見やフィードバックを得て、内容を改善することができます。

#### クローン（Clone）
例え: 本の複製

クローンは、本棚にある本をまるごと「複製」して、自分の手元にコピーを作成することです。これにより、元の本と同じ内容を参照しながら、自分のペースで編集や変更を行うことができます。

#### プル（Pull）
例え: 最新の原稿を取り寄せる

プルは、編集者が最新の原稿を「取り寄せる」ことです。これにより、自分の手元にある原稿を最新の状態に更新できます。

#### プッシュ（Push）
例え: 新しい章を本に追加する

プッシュは、自分の手元にある原稿の変更を「本に追加する」ことです。これにより、他の人もその変更を参照できるようになります。

#### リバート（Revert）
例え: 訂正ページ

リバートは、すでに本に掲載された章を訂正するために「訂正ページ」を追加することです。元の章はそのまま残し、新たにその章が取り消されたことを記録するページを追加します。

#### リセット（Reset）
例え: 原稿の巻き戻し

リセットは、本の原稿を過去のバージョンに「巻き戻す」操作です。以下のモードがあります：
- **`--soft` リセット**：本の章を取り消し、内容を再び下書きノートに戻す。
- **`--mixed` リセット**：本の章を取り消し、ノートからも削除して書き直しの状態にする。
- **`--hard` リセット**：本の章を完全に削除し、ノートにも何も残さない。

#### コンフリクト（Conflict）
例え: 草稿の重複

コンフリクトは、二人の編集者が同じ章を同時に編集し、異なる内容を追加した場合に発生する「草稿の重複」です。これを解決するためには、どちらの変更を採用するかを決める必要があります。


これらを図にわかりやすくまとめたXの投稿があったのでシェアします。
https://x.com/098ra0209/status/1163424568544907265?s=46

## 実際に使ってみよう
### 0.事前準備
:::details Git/GitHubの導入手順
Windowsの方👇
https://prog-8.com/docs/git-env-win
Macの方👇
https://prog-8.com/docs/git-env
:::

### 1.リポジトリの作成とクローン
ここではリポジトリを新規作成し、既存のリポジトリをクローンできる状態を目指します。
#### リポジトリの新規作成
1. ターミナルを開きます。
2. 新規リポジトリを作成したいディレクトリに移動します。
3. 次のコマンドを実行してリポジトリを作成します：

```zsh
git init
```

これで、現在のディレクトリに新しいGitリポジトリが作成されました。

#### 既存リポジトリのクローン
1. ターミナルを開きます。
2. クローンしたいディレクトリに移動します。
3. 次のコマンドを実行して既存のリポジトリをクローンします：

```zsh
git clone <リポジトリのURL>
```

例：

```zsh
git clone https://github.com/example/repo.git
```

これで、指定したリポジトリが現在のディレクトリにクローンされました。

### 2. コミットの基本操作
ここでは変更をステージングし、コミットメッセージを付けて記録できる状態を目指します。
#### ステージングとコミットの手順
1. ファイルを変更する
→まず、リポジトリ内のファイルを編集して変更を加えます。

2. 変更をステージングする
→変更したファイルをステージングエリアに追加する為に次のコマンドを実行します:

```zsh
git add <ファイル名>
```

例：

```zsh
git add README.md
```

複数のファイルをステージングする場合やすべての変更をステージングする場合：

```zsh
git add .
```

3. 変更をコミットする

ステージングエリアに追加した変更をコミットする為に次のコマンドを実行します：

```zsh
git commit -m "コミットメッセージ"
```

例：

```zsh
git commit -m "READMEを更新しました"
```

これで、変更がリポジトリにコミットされ、履歴に記録されました。コミットメッセージには、変更内容を簡潔に説明するコメントを入れることが推奨されます。

### 3. ブランチの管理
ここでは新しいブランチを作成し、ブランチ間の切り替えやマージができる状態を目指します。
#### 新しいブランチの作成

1. 新しいブランチを作成する為に次のコマンドを実行します：

```zsh
git branch <ブランチ名>
```

例：

```zsh
git branch feature-branch
```

#### ブランチ間の切り替え

1. 別のブランチに切り替える為に次のコマンドを実行します：

```zsh
git checkout <ブランチ名>
```

例：

```zsh
git checkout feature-branch
```

現在のブランチは `feature-branch` に切り替わりました。

2. ブランチを作成と同時に切り替えたい場合は、次のコマンドを使用します：

```zsh
git checkout -b <ブランチ名>
```

例：

```zsh
git checkout -b new-feature
```

#### ブランチのマージ

1. マージしたいブランチに切り替えます。例えば、 `main` ブランチにマージする場合：

```zsh
git checkout main
```

2. 次に、マージしたいブランチを指定してマージします：

```zsh
git merge <ブランチ名>
```

例：

```zsh
git merge feature-branch
```

これで、 `feature-branch` の変更が `main` ブランチにマージされました。

#### マージコンフリクトの解決

マージ中にコンフリクトが発生した場合、次の手順で解決します：

1. コンフリクトのあるファイルを編集して、必要な変更を手動でマージします。
2. 編集が完了したら、コンフリクトを解決したファイルをステージングします：

```zsh
git add <ファイル名>
```

3. マージを完了するために、再度コミットします：

```zsh
git commit
```

これで、マージコンフリクトが解決され、変更がマージされます。
### 4. リモートリポジトリの操作
ここではリモートリポジトリへのプッシュやリモートからのプルができる状態を目指します。
#### リモートリポジトリへのプッシュ

1. **リモートリポジトリを追加する**（もしまだ追加していない場合）：

```zsh
git remote add origin <リモートリポジトリのURL>
```

例：

```zsh
git remote add origin https://github.com/ユーザー名/リポジトリ名.git
```

2. **変更をプッシュする**：

リモートリポジトリに変更をプッシュするには、次のコマンドを実行します：

```zsh
git push origin <ブランチ名>
```

例：

```zsh
git push origin main
```

これで、ローカルの `main` ブランチの変更がリモートリポジトリにプッシュされました。

#### リモートリポジトリからのプル

1. **リモートリポジトリから変更をプルする**：

リモートリポジトリから最新の変更をプルするには、次のコマンドを実行します：

```zsh
git pull origin <ブランチ名>
```

例：

```zsh
git pull origin main
```

これで、リモートの `main` ブランチの最新の変更がローカルリポジトリにマージされました。
#### まとめ
- リモートリポジトリを追加するには `git remote add origin <リモートリポジトリのURL>` を使用します。
- ローカルの変更をリモートリポジトリにプッシュするには `git push origin <ブランチ名>` を使用します。
- リモートリポジトリから最新の変更をプルするには `git pull origin <ブランチ名>` を使用します。

これでリモートリポジトリの操作ができるようになりました。
### 5. 差分の確認
ここでは変更内容を差分として確認し、適切にレビューできる状態を目指します。
#### 変更内容を差分として確認する

1. **ローカルの変更を確認する**

現在の作業ディレクトリ内の変更内容を確認するには、次のコマンドを使用します：

```zsh
git diff
```

これは、作業ツリー内の変更を表示します。

2. **ステージングエリアの変更を確認する**

ステージングエリアに追加された変更内容を確認するには、次のコマンドを使用します：

```zsh
git diff --staged
```

これは、ステージングエリアに追加されたファイルの差分を表示します。

3. **特定のコミット間の差分を確認する**

特定のコミット間の差分を確認するには、次のコマンドを使用します：

```zsh
git diff <コミット1> <コミット2>
```

例：

```zsh
git diff HEAD~1 HEAD
```

これは、最新のコミットとその1つ前のコミットの間の差分を表示します。

4. **ブランチ間の差分を確認する**

ブランチ間の差分を確認するには、次のコマンドを使用します：

```zsh
git diff <ブランチ1> <ブランチ2>
```

例：

```zsh
git diff main feature-branch
```

これは、`main` ブランチと `feature-branch` の間の差分を表示します。
#### まとめ
- **ローカルの変更**を確認するには `git diff` を使用します。
- **ステージングエリアの変更**を確認するには `git diff --staged` を使用します。
- **特定のコミット間の差分**を確認するには `git diff <コミット1> <コミット2>` を使用します。
- **ブランチ間の差分**を確認するには `git diff <ブランチ1> <ブランチ2>` を使用します。

これで、変更内容を差分として確認し、適切にレビューできるようになりました。
### 6. コンフリクトの解決
ここではマージコンフリクトが発生した際に、それを解決できる状態を目指します。
#### マージコンフリクトの解決手順

1. **マージの実行**

まず、ブランチをマージする為に次のコマンドを実行します：

```zsh
git merge <マージしたいブランチ>
```

例：

```zsh
git merge feature-branch
```

マージ中にコンフリクトが発生した場合、Gitは自動的にマージを停止し、コンフリクトのあるファイルを表示します。

2. **コンフリクトの確認**

コンフリクトのあるファイルを確認します。次のコマンドを実行して、どのファイルにコンフリクトがあるかを確認します：

```zsh
git status
```

コンフリクトのあるファイルには `both modified` と表示されます。

3. **コンフリクトの解消**

コンフリクトのあるファイルを開き、手動で編集します。コンフリクト部分は次のように表示されます：

```plaintext
<<<<<<< HEAD
現在の変更内容
=======
マージ先の変更内容
>>>>>>> feature-branch
```

`HEAD` 部分は現在のブランチの変更内容を示し、`feature-branch` 部分はマージしようとしているブランチの変更内容を示します。これらを適切に編集して、コンフリクトを解消します。

4. **コンフリクト解消後のステージング**

コンフリクトを解消したファイルをステージングします：

```zsh
git add <ファイル名>
```

例：

```zsh
git add conflicted-file.txt
```

5. **マージの完了**

すべてのコンフリクトが解消され、ファイルがステージングされたら、次のコマンドを実行してマージを完了します：

```zsh
git commit
```

Gitは自動的にマージコミットメッセージを生成します。
#### まとめ
1. **マージの実行**：`git merge <マージしたいブランチ>`
2. **コンフリクトの確認**：`git status`
3. **コンフリクトの解消**：ファイルを手動で編集
4. **コンフリクト解消後のステージング**：`git add <ファイル名>`
5. **マージの完了**：`git commit`

これで、マージコンフリクトが発生した際に、それを解決できるようになりました。
### 7. ログの確認
ここではコミット履歴を確認し、必要に応じて特定のバージョンに戻ることができる状態を目指します。
#### コミット履歴の確認

1. **基本的なログの表示**

コミット履歴を確認するには、次のコマンドを使用します：

```zsh
git log
```

これで、コミットメッセージ、コミットハッシュ、著者、日付などが表示されます。

2. **簡潔なログ表示**

より簡潔な形式でログを確認するには、次のコマンドを使用します：

```zsh
git log --oneline
```

これにより、各コミットが一行で表示されます。

3. **特定のファイルに対するログの確認**

特定のファイルに対するコミット履歴を確認するには、次のコマンドを使用します：

```zsh
git log <ファイル名>
```

例：

```zsh
git log README.md
```

#### 特定のバージョンに戻る

1. **過去のコミットをチェックアウトする**

特定のバージョンに一時的に戻るには、次のコマンドを使用します：

```zsh
git checkout <コミットハッシュ>
```

例：

```zsh
git checkout abc1234
```

これで、指定したコミットの状態にリポジトリが戻ります。ただし、この状態は一時的なものであり、新しいブランチを作成しない限り、変更は保存されません。

2. **特定のコミットから新しいブランチを作成する**

特定のコミットから新しいブランチを作成して、そこから作業を続ける場合は、次のコマンドを使用します：

```zsh
git checkout -b <新しいブランチ名> <コミットハッシュ>
```

例：

```zsh
git checkout -b old-state abc1234
```

3. **リセットで過去のコミットに戻る**

リポジトリの状態を過去のコミットに戻し、変更を破棄する場合は、次のコマンドを使用します：

```zsh
git reset --hard <コミットハッシュ>
```

例：

```zsh
git reset --hard abc1234
```
#### まとめ
- **基本的なログの確認**：`git log`
- **簡潔なログ表示**：`git log --oneline`
- **特定のファイルに対するログの確認**：`git log <ファイル名>`
- **過去のコミットをチェックアウト**：`git checkout <コミットハッシュ>`
- **特定のコミットから新しいブランチを作成**：`git checkout -b <新しいブランチ名> <コミットハッシュ>`
- **リセットで過去のコミットに戻る**：`git reset --hard <コミットハッシュ>`

これで、コミット履歴を確認し、必要に応じて特定のバージョンに戻ることができるようになりました。

### 8. リセットやリバート
ここでは間違ったコミットを取り消したり、過去の状態に戻したりする操作ができる状態を目指します。
#### リセット

`git reset` コマンドは、コミットやステージングエリア、ワーキングディレクトリの状態を変更するために使用されます。リセットには3つのモードがあります：`--soft`、`--mixed`、`--hard`。

1. **`--soft` リセット**

コミットを取り消し、変更内容をステージングエリアに残す：

```zsh
git reset --soft <コミットハッシュ>
```

例：

```zsh
git reset --soft HEAD~1
```

2. **`--mixed` リセット（デフォルト）**

コミットを取り消し、変更内容をワーキングディレクトリに残す：

```zsh
git reset --mixed <コミットハッシュ>
```

例：

```zsh
git reset --mixed HEAD~1
```

3. **`--hard` リセット**

コミットを取り消し、変更内容を完全に削除する：

```zsh
git reset --hard <コミットハッシュ>
```

例：

```zsh
git reset --hard HEAD~1
```

#### リバート

`git revert` コマンドは、特定のコミットを取り消すために使用されますが、リセットとは異なり、リポジトリの履歴を保持します。リバートは新しいコミットを作成し、指定したコミットの変更を取り消します。

1. **特定のコミットをリバートする**

```zsh
git revert <コミットハッシュ>
```

例：

```zsh
git revert abc1234
```

これで、コミット `abc1234` の変更を取り消す新しいコミットが作成されます。
#### まとめ
- **`--soft` リセット**：コミットを取り消し、変更をステージングエリアに残す。
- **`--mixed` リセット**：コミットを取り消し、変更をワーキングディレクトリに残す。
- **`--hard` リセット**：コミットを取り消し、変更を完全に削除する。
- **リバート**：特定のコミットを取り消す新しいコミットを作成する。

これで、間違ったコミットを取り消したり、過去の状態に戻したりする操作ができるようになりました。

## さいごに
ここまでGitについて解説しましたが、まだまだGitには沢山の機能があります。ここまで学んだ基礎知識があるあなたは今後は開発をしながら学んでいくスタイルにシフトするのも良いかもしれません。今回、本記事を書くために2週間かけてGitを勉強しました。Gitの為だけに2週間も費やすのは少々勿体無い気もしますが、本記事があなたのお役に立てば幸いです。

## 参考文献
https://git-scm.com/docs
https://backlog.com/ja/git-tutorial/
https://tracpath.com/bootcamp/learning_git_firststep.html